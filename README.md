sbt "runMain lambda.LambdaREPL --test"

sbt run

Работа парсера(на поиск ошибок)
Testing '(λfλx.f (f x)) (λz.z) w'... ✗ Parse error: Position 1:4, found "λx.f (f x)"

Немножко теории:
1. β-редукция 
    Основное правило вычислений: (λx.M) N → M[x:=N]
    Реализовано в LambdaEvaluator.betaReduce через подстановку (substitute)

2. α-конверсия
    Переименование связанных переменных для избежания коллизий: λx.x → λy.y
    Реализовано в substitute через генерацию свежих имен (freshName)

3. Нормальная форма
    Вычисление до тех пор, пока больше нельзя применить β-редукцию
    Реализовано в evaluate через итеративное применение betaReduce

4. Нумералы Чёрча 
    Числа как функции:
    0 = λf.λx.x,
    1 = λf.λx.f x,
    n = λf.λx.fⁿ x

    Парсятся из цифр (churchNumeral в парсере)

5. Типизация по Хиндли-Милнеру
    Рекурсивный вывод типов с унификацией
    Основные правила:
        Γ ⊢ x : σ    (x:σ ∈ Γ)  
        Γ ⊢ λx.M : σ→τ    (Γ,x:σ ⊢ M : τ)  
        Γ ⊢ M N : τ    (Γ ⊢ M : σ→τ, Γ ⊢ N : σ)

        Реализовано в TypeInference

Примеры теоретических преобразований
    β-редукция:
    (λx.x) y → y

    α-конверсия:
    λx.λy.x → λx.λz.x (избегаем захват y)

    Типизация:
    λx.x : α → α (тождественная функция)

    Числа Чёрча:
    2 = λf.λx.f (f x) (два применения функции)


TODO:
Добавление условных конструкций(if-else) и рекурсии